// +build !debug

// This file is generated by the vault-cli command line utility.
// It offers a easy way to embed binary resources into a go executable.
// DO NOT EDIT this file, it will be overwritten on the next run of the vault-cli utility.

package res

import (
	"compress/zlib"
	"errors"
	"io"
	"os"
	"strings"
	"time"
)

var vaultAssetBinReact = ""

// Remove next line
var mf File = &memFile{}

type assetReader interface {
	io.ReadCloser
	zlib.Resetter
}

type memFile struct {
	r       assetReader
	rOffset int64
	offset  int64
	name    string
	modTime time.Time
	path    string
	length  int64
	size    int64
}

// Readdir see os.File Readdir function
func (m memFile) Readdir(count int) ([]os.FileInfo, error) {
	return []os.FileInfo{}, io.EOF
}

func (m memFile) Close() error {
	return m.r.Close()
}

func (m *memFile) resetReader() error {
	var r io.ReadCloser
	var err error
	if m.r == nil {
		r, err = zlib.NewReader(strings.NewReader(vaultAssetBinReact[m.offset : m.offset+m.length]))
	} else {
		err = m.r.Reset(strings.NewReader(vaultAssetBinReact[m.offset:m.offset+m.length]), nil)
	}

	if err != nil {
		return err
	}

	m.r = r.(assetReader)
	m.rOffset = 0
	return nil
}

func (m *memFile) Read(p []byte) (n int, err error) {
	if m.r == nil {
		if err := m.resetReader(); err != nil {
			return 0, err
		}
	}

	n, err = m.r.Read(p)
	m.rOffset += int64(n)
	return n, err
}

func (m *memFile) Seek(offset int64, whence int) (int64, error) {
	switch whence {
	case io.SeekCurrent:
		offset += m.rOffset
	case io.SeekStart:
	case io.SeekEnd:
		offset += m.length
	default:
		return 0, errors.New("Seek: invalid whence")

	}

	if offset < 0 {
		return m.rOffset, errors.New("Seek: invalid offset")
	}

	if offset < m.rOffset {
		if err := m.resetReader(); err != nil {
			return m.rOffset, err
		}
	}

	buf := make([]byte, offset)
	_, err := m.Read(buf)
	return m.rOffset, err
}

func (m memFile) Stat() (os.FileInfo, error) {
	return m, nil
}

func (m memFile) Name() string {
	return m.name
}

func (m memFile) Size() int64 {
	return m.size
}

func (m memFile) Mode() os.FileMode {
	return 0444
}

func (m memFile) ModTime() time.Time {
	return m.modTime
}

func (m memFile) IsDir() bool {
	return false
}

func (m memFile) Sys() interface{} {
	return nil
}

type memDir struct {
	dir   string
	files []os.FileInfo
	size  int64
}

func (m memDir) Close() error {
	return nil
}

func (m memDir) Read(p []byte) (n int, err error) {
	return 0, errors.New("Read: invalid operation on directory")
}

func (m memDir) Seek(offset int64, whence int) (int64, error) {
	return 0, errors.New("Seek: invalid operation on directory")
}

func (m *memDir) Readdir(count int) ([]os.FileInfo, error) {
	defer func() {
		if count <= 0 || count >= len(m.files) {
			m.files = m.files[0:0]
		} else {
			m.files = m.files[:count]
		}
	}()

	if count <= 0 {
		return m.files[:], nil
	} else if count >= len(m.files) {
		return m.files[:], io.EOF
	}

	return m.files[:count], nil
}

func (m memDir) Stat() (os.FileInfo, error) {
	return m, nil
}

func (m memDir) Name() string {
	if m.dir == "/" {
		return "/"
	}
	return m.dir[strings.LastIndex(m.dir, "/"):]
}

func (m memDir) Size() int64 {
	return m.size
}

func (m memDir) Mode() os.FileMode {
	return os.FileMode(0555)
}

func (m memDir) ModTime() time.Time {
	// Until now no directory information is stored
	// in the asset data, so for now we return the current
	// time.
	return time.Now()
}

func (m memDir) IsDir() bool {
	return true
}

func (m memDir) Sys() interface{} {
	return nil
}

type loader struct {
	fm assetMap
}

func (l loader) Load(name string) (File, error) {
	if !strings.HasPrefix(name, "/") {
		name = "/" + name
	}
	name = strings.TrimRight(name, "/")

	if v, ok := l.fm[name]; ok {
		return &v, nil
	}

	for _, v := range l.fm {
		if v.path == name {
			return createDirFile(name, l.fm), nil
		}
	}

	return nil, ErrNotFound
}

// NewReactLoader returns a new AssetLoader for the React resources.
func NewReactLoader() AssetLoader {
	loader := &loader{
		fm: assetMap{
			"/asset-manifest.json": memFile{offset: 0,
				name:    "asset-manifest.json",
				modTime: time.Unix(1527796009, 0),
				path:    "/",
				size:    257,
				length:  122,
			},
			"/favicon.ico": memFile{offset: 122,
				name:    "favicon.ico",
				modTime: time.Unix(1527796004, 0),
				path:    "/",
				size:    3870,
				length:  3646,
			},
			"/index.html": memFile{offset: 3768,
				name:    "index.html",
				modTime: time.Unix(1527796009, 0),
				path:    "/",
				size:    548,
				length:  343,
			},
			"/manifest.json": memFile{offset: 4111,
				name:    "manifest.json",
				modTime: time.Unix(1527796004, 0),
				path:    "/",
				size:    317,
				length:  212,
			},
			"/service-worker.js": memFile{offset: 4323,
				name:    "service-worker.js",
				modTime: time.Unix(1527796009, 0),
				path:    "/",
				size:    3235,
				length:  1349,
			},
			"/static/css/main.4ba88f14.css": memFile{offset: 5672,
				name:    "main.4ba88f14.css",
				modTime: time.Unix(1527796009, 0),
				path:    "/static/css",
				size:    752,
				length:  340,
			},
			"/static/css/main.4ba88f14.css.map": memFile{offset: 6012,
				name:    "main.4ba88f14.css.map",
				modTime: time.Unix(1527796009, 0),
				path:    "/static/css",
				size:    1520,
				length:  619,
			},
			"/static/js/main.8d71e87d.js": memFile{offset: 6631,
				name:    "main.8d71e87d.js",
				modTime: time.Unix(1527796009, 0),
				path:    "/static/js",
				size:    119028,
				length:  38047,
			},
			"/static/js/main.8d71e87d.js.map": memFile{offset: 44678,
				name:    "main.8d71e87d.js.map",
				modTime: time.Unix(1527796009, 0),
				path:    "/static/js",
				size:    483623,
				length:  150076,
			},
			"/static/media/logo.5d5d9eef.svg": memFile{offset: 194754,
				name:    "logo.5d5d9eef.svg",
				modTime: time.Unix(1527796009, 0),
				path:    "/static/media",
				size:    2671,
				length:  1281,
			},
		},
	}
	return loader
}
