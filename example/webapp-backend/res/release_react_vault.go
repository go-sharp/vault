// +build !debug

// This file is generated by the vault-cli command line utility.
// It offers a easy way to embed binary resources into a go executable.
// DO NOT EDIT this file, it will be overwritten on the next run of the vault-cli utility.

package res

import (
	"compress/zlib"
	"errors"
	"fmt"
	"io"
	"os"
	"sort"
	"strings"
	"time"
)

var vaultAssetBinReact = ""

// Remove next line
var mf File = &memFile{}

type assetReader interface {
	io.ReadCloser
	zlib.Resetter
}

type memFile struct {
	r       assetReader
	rOffset int64
	offset  int64
	name    string
	modTime time.Time
	path    string
	length  int64
	size    int64
}

// Readdir see os.File Readdir function
func (m memFile) Readdir(count int) ([]os.FileInfo, error) {
	return []os.FileInfo{}, io.EOF
}

func (m memFile) Close() error {
	return m.r.Close()
}

func (m *memFile) resetReader() error {
	var r io.ReadCloser
	var err error
	if m.r == nil {
		r, err = zlib.NewReader(strings.NewReader(vaultAssetBinReact[m.offset : m.offset+m.length]))
	} else {
		err = m.r.Reset(strings.NewReader(vaultAssetBinReact[m.offset:m.offset+m.length]), nil)
	}

	if err != nil {
		return err
	}

	m.r = r.(assetReader)
	m.rOffset = 0
	return nil
}

func (m *memFile) Read(p []byte) (n int, err error) {
	if m.r == nil {
		if err := m.resetReader(); err != nil {
			return 0, err
		}
	}

	n, err = m.r.Read(p)
	m.rOffset += int64(n)
	return n, err
}

func (m *memFile) Seek(offset int64, whence int) (int64, error) {
	switch whence {
	case io.SeekCurrent:
		offset += m.rOffset
	case io.SeekStart:
	case io.SeekEnd:
		offset += m.length
	default:
		return 0, errors.New("Seek: invalid whence")

	}

	if offset < 0 {
		return m.rOffset, errors.New("Seek: invalid offset")
	}

	if offset < m.rOffset {
		if err := m.resetReader(); err != nil {
			return m.rOffset, err
		}
	}

	buf := make([]byte, offset)
	_, err := m.Read(buf)
	return m.rOffset, err
}

func (m memFile) Stat() (os.FileInfo, error) {
	return m, nil
}

func (m memFile) Name() string {
	return m.name
}

func (m memFile) Size() int64 {
	return m.size
}

func (m memFile) Mode() os.FileMode {
	return 0444
}

func (m memFile) ModTime() time.Time {
	return m.modTime
}

func (m memFile) IsDir() bool {
	return false
}

func (m memFile) Sys() interface{} {
	return nil
}

type memDir struct {
	dir    string
	fm     assetMap
	offset int
}

func (m memDir) Close() error {
	return nil
}

func (m memDir) Read(p []byte) (n int, err error) {
	return 0, errors.New("Read: invalid operation on directory")
}

func (m memDir) Seek(offset int64, whence int) (int64, error) {
	return 0, errors.New("Seek: invalid operation on directory")
}

func (m memDir) Readdir(count int) ([]os.FileInfo, error) {
	var files []os.FileInfo
	var dirs []string
	contains := func(s string) bool {
		for i := range dirs {
			if dirs[i] == s {
				return true
			}
		}
		return false
	}

	for _, v := range m.fm {
		if v.path == m.dir {
			files = append(files, v)
			continue
		}
		if strings.HasPrefix(v.path, m.dir) {
			path := strings.TrimLeft(v.path, m.dir)
			path = strings.TrimRightFunc(path, func(rune) bool {
				// TODO: Remove trailing path segments
				return false
			})
			if !contains(path) {
				dirs = append(dirs, path)
				files = append(files, memDir{dir: fmt.Sprintf("%v/%v", m.dir, path), fm: m.fm.filterPath(m.dir)})
			}
		}
	}

	sort.Slice(files, func(i int, j int) bool {
		first := files[i]
		second := files[j]

		switch ft := first.(type) {
		case memDir:
			st, ok := second.(memDir)
			if ok {
				return ft.dir < st.dir
			}
			return true
		case memFile:
			st, ok := second.(memFile)
			if ok {
				return ft.name < st.name
			}
			return false
		default:
			panic("invalid slice type")
		}
	})

	return nil, nil
}

func (m memDir) Stat() (os.FileInfo, error) {
	panic("not implemented")
}

func (m memDir) Name() string {
	panic("not implemented")
}

func (m memDir) Size() int64 {
	panic("not implemented")
}

func (m memDir) Mode() os.FileMode {
	panic("not implemented")
}

func (m memDir) ModTime() time.Time {
	panic("not implemented")
}

func (m memDir) IsDir() bool {
	panic("not implemented")
}

func (m memDir) Sys() interface{} {
	panic("not implemented")
}

type assetMap map[string]memFile

func (a assetMap) filterPath(path string) assetMap {
	mm := assetMap{}
	for k, v := range a {
		if strings.HasPrefix(v.path, path) {
			mm[k] = v
		}
	}
	return mm
}

type loader struct {
	fm assetMap
}

func (l loader) Load(name string) (File, error) {
	if !strings.HasPrefix(name, "/") {
		name = "/" + name
	}

	if v, ok := l.fm[name]; ok {
		return &v, nil
	}
	return nil, ErrNotFound
}

// NewReactLoader returns a new AssetLoader for the React resources.
func NewReactLoader() AssetLoader {
	loader := &loader{
		fm: assetMap{
			"/asset-manifest.json": memFile{offset: 0,
				name:    "asset-manifest.json",
				modTime: time.Unix(1527796009, 0),
				path:    "/",
				size:    257,
				length:  122,
			},
			"/favicon.ico": memFile{offset: 122,
				name:    "favicon.ico",
				modTime: time.Unix(1527796004, 0),
				path:    "/",
				size:    3870,
				length:  3646,
			},
			"/index.html": memFile{offset: 3768,
				name:    "index.html",
				modTime: time.Unix(1527796009, 0),
				path:    "/",
				size:    548,
				length:  343,
			},
			"/manifest.json": memFile{offset: 4111,
				name:    "manifest.json",
				modTime: time.Unix(1527796004, 0),
				path:    "/",
				size:    317,
				length:  212,
			},
			"/service-worker.js": memFile{offset: 4323,
				name:    "service-worker.js",
				modTime: time.Unix(1527796009, 0),
				path:    "/",
				size:    3235,
				length:  1349,
			},
			"/static/css/main.4ba88f14.css": memFile{offset: 5672,
				name:    "main.4ba88f14.css",
				modTime: time.Unix(1527796009, 0),
				path:    "/static/css",
				size:    752,
				length:  340,
			},
			"/static/css/main.4ba88f14.css.map": memFile{offset: 6012,
				name:    "main.4ba88f14.css.map",
				modTime: time.Unix(1527796009, 0),
				path:    "/static/css",
				size:    1520,
				length:  619,
			},
			"/static/js/main.8d71e87d.js": memFile{offset: 6631,
				name:    "main.8d71e87d.js",
				modTime: time.Unix(1527796009, 0),
				path:    "/static/js",
				size:    119028,
				length:  38047,
			},
			"/static/js/main.8d71e87d.js.map": memFile{offset: 44678,
				name:    "main.8d71e87d.js.map",
				modTime: time.Unix(1527796009, 0),
				path:    "/static/js",
				size:    483623,
				length:  150076,
			},
			"/static/media/logo.5d5d9eef.svg": memFile{offset: 194754,
				name:    "logo.5d5d9eef.svg",
				modTime: time.Unix(1527796009, 0),
				path:    "/static/media",
				size:    2671,
				length:  1281,
			},
		},
	}
	return loader
}
